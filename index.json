{
  "api/CatchIo.Camera.CameraManager.html": {
    "href": "api/CatchIo.Camera.CameraManager.html",
    "title": "Class CameraManager | Catch.io Developer Reference",
    "keywords": "Class CameraManager The main camera class for in-game camera movements. By passing the player object as its member, this object will initialize all the camera setup and follow the provided player. There should only be one instance of this object per scene. Inheritance Object CameraManager Namespace : CatchIo.Camera Assembly : cs.temp.dll.dll Syntax public class CameraManager : MonoBehaviour Fields PlayerToFollow The player object that this camera will follow. Declaration public GameObject PlayerToFollow Field Value Type Description GameObject Methods SetupCamera() Initialization function. This is where the components are obtained and cached to the class. Declaration public void SetupCamera()"
  },
  "api/CatchIo.Camera.CameraTargetMovement.html": {
    "href": "api/CatchIo.Camera.CameraTargetMovement.html",
    "title": "Class CameraTargetMovement | Catch.io Developer Reference",
    "keywords": "Class CameraTargetMovement Camera movement logic to make view transition smooth. This object should be a child of the main camera object. Inheritance Object CameraTargetMovement Namespace : CatchIo.Camera Assembly : cs.temp.dll.dll Syntax public class CameraTargetMovement : MonoBehaviour Fields ClampXDistance Clamp X distance for the smooth effect Declaration public float ClampXDistance Field Value Type Description Single ClampYDistance Clamp Y distance of the smooth effect Declaration public float ClampYDistance Field Value Type Description Single Methods Move(UnityEngine.Camera, GameObject) Smoothly move the given game camera object's view based on the player's direction input. Declaration public void Move(UnityEngine.Camera mainCamera, GameObject objectToFollow) Parameters Type Name Description UnityEngine.Camera mainCamera GameObject objectToFollow"
  },
  "api/CatchIo.Camera.html": {
    "href": "api/CatchIo.Camera.html",
    "title": "Namespace CatchIo.Camera | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Camera Classes CameraManager The main camera class for in-game camera movements. By passing the player object as its member, this object will initialize all the camera setup and follow the provided player. There should only be one instance of this object per scene. CameraTargetMovement Camera movement logic to make view transition smooth. This object should be a child of the main camera object."
  },
  "api/CatchIo.Core.GuiBehavior.html": {
    "href": "api/CatchIo.Core.GuiBehavior.html",
    "title": "Class GuiBehavior | Catch.io Developer Reference",
    "keywords": "Class GuiBehavior Base class used for components that has to work with scene UI elements and their behaviors. Inheritance Object GuiBehavior Namespace : CatchIo.Core Assembly : cs.temp.dll.dll Syntax public abstract class GuiBehavior : MonoBehaviour"
  },
  "api/CatchIo.Core.html": {
    "href": "api/CatchIo.Core.html",
    "title": "Namespace CatchIo.Core | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Core Classes GuiBehavior Base class used for components that has to work with scene UI elements and their behaviors. NetworkCallback Base class for manager scripts that works with PUN callbacks. This script is not meant to be used as a component, rather, other game managers are expected to inherit from this class."
  },
  "api/CatchIo.Core.NetworkCallback.html": {
    "href": "api/CatchIo.Core.NetworkCallback.html",
    "title": "Class NetworkCallback | Catch.io Developer Reference",
    "keywords": "Class NetworkCallback Base class for manager scripts that works with PUN callbacks. This script is not meant to be used as a component, rather, other game managers are expected to inherit from this class. Inheritance Object NetworkCallback Namespace : CatchIo.Core Assembly : cs.temp.dll.dll Syntax public class NetworkCallback : MonoBehaviourPunCallbacks Fields GameVersion This client's version number. Users are separated from each other by gameVersion (which allows you to make breaking changes). Declaration public string GameVersion Field Value Type Description String Methods OnCreateRoomFailed(Int16, String) Declaration public override void OnCreateRoomFailed(short returnCode, string message) Parameters Type Name Description Int16 returnCode String message OnDisconnected(DisconnectCause) Declaration public override void OnDisconnected(DisconnectCause cause) Parameters Type Name Description DisconnectCause cause OnJoinRoomFailed(Int16, String) Declaration public override void OnJoinRoomFailed(short returnCode, string message) Parameters Type Name Description Int16 returnCode String message"
  },
  "api/CatchIo.Effects.DissolveEffeect.html": {
    "href": "api/CatchIo.Effects.DissolveEffeect.html",
    "title": "Class DissolveEffeect | Catch.io Developer Reference",
    "keywords": "Class DissolveEffeect Inheritance Object EffectBase DissolveEffeect Inherited Members EffectBase.EffectSource EffectBase.Duration EffectBase.EffectPlayable EffectBase.TargetRenderer Namespace : CatchIo.Effects Assembly : cs.temp.dll.dll Syntax public class DissolveEffeect : EffectBase Methods EffectExecutor() Declaration public override IEnumerator EffectExecutor() Returns Type Description IEnumerator Overrides EffectBase.EffectExecutor() EffectReverser() Declaration public IEnumerator EffectReverser() Returns Type Description IEnumerator Play(IEffectPlayable, Renderer) Declaration public override void Play(IEffectPlayable effectPlayable, Renderer renderer) Parameters Type Name Description IEffectPlayable effectPlayable Renderer renderer Overrides EffectBase.Play(IEffectPlayable, Renderer)"
  },
  "api/CatchIo.Effects.EffectBase.html": {
    "href": "api/CatchIo.Effects.EffectBase.html",
    "title": "Class EffectBase | Catch.io Developer Reference",
    "keywords": "Class EffectBase Base scriptable object related to effect materials. Inheritance Object EffectBase DissolveEffeect Namespace : CatchIo.Effects Assembly : cs.temp.dll.dll Syntax public abstract class EffectBase : ScriptableObject Fields Duration Declaration public float Duration Field Value Type Description Single EffectPlayable Declaration protected IEffectPlayable EffectPlayable Field Value Type Description IEffectPlayable EffectSource Declaration public Material EffectSource Field Value Type Description Material TargetRenderer Declaration protected Renderer TargetRenderer Field Value Type Description Renderer Methods EffectExecutor() Declaration public abstract IEnumerator EffectExecutor() Returns Type Description IEnumerator Play(IEffectPlayable, Renderer) Declaration public virtual void Play(IEffectPlayable effectPlayable, Renderer renderer) Parameters Type Name Description IEffectPlayable effectPlayable Renderer renderer"
  },
  "api/CatchIo.Effects.html": {
    "href": "api/CatchIo.Effects.html",
    "title": "Namespace CatchIo.Effects | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Effects Classes DissolveEffeect EffectBase Base scriptable object related to effect materials. Interfaces IEffectPlayable Interface inherited by objects that contains a playable effect."
  },
  "api/CatchIo.Effects.IEffectPlayable.html": {
    "href": "api/CatchIo.Effects.IEffectPlayable.html",
    "title": "Interface IEffectPlayable | Catch.io Developer Reference",
    "keywords": "Interface IEffectPlayable Interface inherited by objects that contains a playable effect. Namespace : CatchIo.Effects Assembly : cs.temp.dll.dll Syntax public interface IEffectPlayable Methods EffectSequence() Declaration IEnumerator EffectSequence() Returns Type Description IEnumerator ExecuteEffect() Declaration void ExecuteEffect() OnEndEffect() Declaration void OnEndEffect()"
  },
  "api/CatchIo.Enums.html": {
    "href": "api/CatchIo.Enums.html",
    "title": "Namespace CatchIo.Enums | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Enums Enums MenuScenes"
  },
  "api/CatchIo.Enums.MenuScenes.html": {
    "href": "api/CatchIo.Enums.MenuScenes.html",
    "title": "Enum MenuScenes | Catch.io Developer Reference",
    "keywords": "Enum MenuScenes Namespace : CatchIo.Enums Assembly : cs.temp.dll.dll Syntax public enum MenuScenes Fields Name Description Launcher LobbyMenu"
  },
  "api/CatchIo.Environment.html": {
    "href": "api/CatchIo.Environment.html",
    "title": "Namespace CatchIo.Environment | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Environment Classes Surface Game map surface utility class. This class contains various methods and types for referencing tilemap surfaces. NOTE: Right now everything is hard-coded for surface detection. We need to make this more scalable. TileSurface Interfaces IReactsToSurfaceType ISurfaceTrigger Enums Surface.SurfaceType"
  },
  "api/CatchIo.Environment.IReactsToSurfaceType.html": {
    "href": "api/CatchIo.Environment.IReactsToSurfaceType.html",
    "title": "Interface IReactsToSurfaceType | Catch.io Developer Reference",
    "keywords": "Interface IReactsToSurfaceType Namespace : CatchIo.Environment Assembly : cs.temp.dll.dll Syntax public interface IReactsToSurfaceType Methods OnEnteredSurface(TileSurface) Declaration void OnEnteredSurface(TileSurface surface) Parameters Type Name Description TileSurface surface"
  },
  "api/CatchIo.Environment.ISurfaceTrigger.html": {
    "href": "api/CatchIo.Environment.ISurfaceTrigger.html",
    "title": "Interface ISurfaceTrigger | Catch.io Developer Reference",
    "keywords": "Interface ISurfaceTrigger Namespace : CatchIo.Environment Assembly : cs.temp.dll.dll Syntax public interface ISurfaceTrigger Methods OnSurfaceTrigger(GameObject) Declaration void OnSurfaceTrigger(GameObject origin) Parameters Type Name Description GameObject origin"
  },
  "api/CatchIo.Environment.Surface.html": {
    "href": "api/CatchIo.Environment.Surface.html",
    "title": "Class Surface | Catch.io Developer Reference",
    "keywords": "Class Surface Game map surface utility class. This class contains various methods and types for referencing tilemap surfaces. NOTE: Right now everything is hard-coded for surface detection. We need to make this more scalable. Inheritance Object Surface Namespace : CatchIo.Environment Assembly : cs.temp.dll.dll Syntax public static class Surface Fields SurfaceTypeToTileMapName Declaration public static Dictionary<Surface.SurfaceType, string> SurfaceTypeToTileMapName Field Value Type Description Dictionary < Surface.SurfaceType , String > Methods GetSurfaceType(TileBase) Obtain the surface type based on the given tile information via string comparison. Here the name is the asset name on the disk, please make sure to name the tiles appropriately. Declaration public static Surface.SurfaceType GetSurfaceType(TileBase currentTile) Parameters Type Name Description TileBase currentTile Returns Type Description Surface.SurfaceType LeavesFootprints(Surface.SurfaceType) Declaration public static bool LeavesFootprints(Surface.SurfaceType surface) Parameters Type Name Description Surface.SurfaceType surface Returns Type Description Boolean"
  },
  "api/CatchIo.Environment.Surface.SurfaceType.html": {
    "href": "api/CatchIo.Environment.Surface.SurfaceType.html",
    "title": "Enum Surface.SurfaceType | Catch.io Developer Reference",
    "keywords": "Enum Surface.SurfaceType Namespace : CatchIo.Environment Assembly : cs.temp.dll.dll Syntax public enum SurfaceType Fields Name Description Dirt Error Grass Ground Water"
  },
  "api/CatchIo.Environment.TileSurface.html": {
    "href": "api/CatchIo.Environment.TileSurface.html",
    "title": "Class TileSurface | Catch.io Developer Reference",
    "keywords": "Class TileSurface Inheritance Object TileSurface Namespace : CatchIo.Environment Assembly : cs.temp.dll.dll Syntax [Serializable] public class TileSurface Fields FootprintSprite Declaration public Sprite FootprintSprite Field Value Type Description Sprite SoundEffect Declaration public string SoundEffect Field Value Type Description String Properties HasSoundEffect Declaration public bool HasSoundEffect { get; } Property Value Type Description Boolean LeavesFootprints Declaration public bool LeavesFootprints { get; } Property Value Type Description Boolean SoundLevel Declaration public float SoundLevel { get; } Property Value Type Description Single SurfaceName Declaration public string SurfaceName { get; } Property Value Type Description String"
  },
  "api/CatchIo.Helpers.AnimationParser.html": {
    "href": "api/CatchIo.Helpers.AnimationParser.html",
    "title": "Class AnimationParser | Catch.io Developer Reference",
    "keywords": "Class AnimationParser Inheritance Object AnimationParser Namespace : CatchIo.Helpers Assembly : cs.temp.dll.dll Syntax public static class AnimationParser Methods MapAnimationToActionState(AnimationClip[]) Declaration public static Dictionary<CharacterActionState, StateAnimation> MapAnimationToActionState(AnimationClip[] clips) Parameters Type Name Description AnimationClip [] clips Returns Type Description Dictionary < CharacterActionState , StateAnimation >"
  },
  "api/CatchIo.Helpers.html": {
    "href": "api/CatchIo.Helpers.html",
    "title": "Namespace CatchIo.Helpers | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Helpers Classes AnimationParser UserInputHelper Structs StateAnimation"
  },
  "api/CatchIo.Helpers.StateAnimation.html": {
    "href": "api/CatchIo.Helpers.StateAnimation.html",
    "title": "Struct StateAnimation | Catch.io Developer Reference",
    "keywords": "Struct StateAnimation Namespace : CatchIo.Helpers Assembly : cs.temp.dll.dll Syntax public struct StateAnimation Constructors StateAnimation(String, AnimationClip) Declaration public StateAnimation(string name, AnimationClip clip) Parameters Type Name Description String name AnimationClip clip Fields Clip Declaration public AnimationClip Clip Field Value Type Description AnimationClip Name Declaration public string Name Field Value Type Description String"
  },
  "api/CatchIo.Helpers.UserInputHelper.html": {
    "href": "api/CatchIo.Helpers.UserInputHelper.html",
    "title": "Class UserInputHelper | Catch.io Developer Reference",
    "keywords": "Class UserInputHelper Inheritance Object UserInputHelper Namespace : CatchIo.Helpers Assembly : cs.temp.dll.dll Syntax public static class UserInputHelper Methods GetAimModeButtonInput() Declaration public static bool GetAimModeButtonInput() Returns Type Description Boolean GetAttackInput() Declaration public static bool GetAttackInput() Returns Type Description Boolean GetCrouchingButtonInput() Declaration public static bool GetCrouchingButtonInput() Returns Type Description Boolean GetItemSelectInput() Declaration public static int GetItemSelectInput() Returns Type Description Int32 GetItemUseButton() Declaration public static bool GetItemUseButton() Returns Type Description Boolean GetMousePosition() Declaration public static Vector2 GetMousePosition() Returns Type Description Vector2 GetMovementDirectionInput() Declaration public static Vector2 GetMovementDirectionInput() Returns Type Description Vector2 GetRunningButtonInput() Declaration public static bool GetRunningButtonInput() Returns Type Description Boolean"
  },
  "api/CatchIo.Items.ConsumableItem.html": {
    "href": "api/CatchIo.Items.ConsumableItem.html",
    "title": "Class ConsumableItem | Catch.io Developer Reference",
    "keywords": "Class ConsumableItem Base class for consumable items. Inheritance Object Item ConsumableItem StaminaPotion Inherited Members Item.Owner Item.Sprite Item.Start() Item.OnPickup(Character) Item.OnDiscard() Item.CanPickup() Namespace : CatchIo.Items Assembly : cs.temp.dll.dll Syntax public abstract class ConsumableItem : Item Methods Consume() Declaration public abstract void Consume()"
  },
  "api/CatchIo.Items.EvasiveThrowableItem.html": {
    "href": "api/CatchIo.Items.EvasiveThrowableItem.html",
    "title": "Class EvasiveThrowableItem | Catch.io Developer Reference",
    "keywords": "Class EvasiveThrowableItem Base class for evasive throwable items. Inheritance Object Item ThrowableItem EvasiveThrowableItem TeleportRune Implements IThrowable Inherited Members ThrowableItem.GravityMultiplier ThrowableItem.ThrowResolution ThrowableItem.IsOnFloor ThrowableItem.TrajectoryPath ThrowableItem.Rigid2D ThrowableItem.CurrentTrajectoryArc ThrowableItem.HasLanded ThrowableItem.PassedPeak ThrowableItem.ThrowedTime ThrowableItem.Start() ThrowableItem.FixedUpdate() ThrowableItem.UpdateProjectilePhysic(Vector2, Vector2, Single, Single) ThrowableItem.OnThrow() ThrowableItem.OnLanded() ThrowableItem.OnPickup(Character) ThrowableItem.OnBeforeThrow(Vector2, Vector2) ThrowableItem.GetPeakHeight() Item.Owner Item.Sprite Item.OnDiscard() Item.CanPickup() Namespace : CatchIo.Items Assembly : cs.temp.dll.dll Syntax public abstract class EvasiveThrowableItem : ThrowableItem, IThrowable Implements IThrowable"
  },
  "api/CatchIo.Items.html": {
    "href": "api/CatchIo.Items.html",
    "title": "Namespace CatchIo.Items | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Items Classes ConsumableItem Base class for consumable items. EvasiveThrowableItem Base class for evasive throwable items. Item Base class for all items. OffensiveThrowableItem Base class for offensive throwable items. This class causes damage if the other player hitted. StaminaPotion This class recovers by HealVal the character when used by the player. Stone High-level implementation for the stone object. TeleportRune This class can teleport to item landed position with teleport dissolve effect. ThrowableItem Base class for all throwable items. If player throwed this object, it will be placed to mouse-position."
  },
  "api/CatchIo.Items.Item.html": {
    "href": "api/CatchIo.Items.Item.html",
    "title": "Class Item | Catch.io Developer Reference",
    "keywords": "Class Item Base class for all items. Inheritance Object Item ConsumableItem ThrowableItem Namespace : CatchIo.Items Assembly : cs.temp.dll.dll Syntax public abstract class Item : MonoBehaviour Properties Owner Declaration public Character Owner { get; } Property Value Type Description Character Sprite Declaration public Sprite Sprite { get; } Property Value Type Description Sprite Methods CanPickup() Declaration public virtual bool CanPickup() Returns Type Description Boolean OnDiscard() Declaration public virtual void OnDiscard() OnPickup(Character) Declaration public virtual void OnPickup(Character owner) Parameters Type Name Description Character owner Start() Declaration protected virtual void Start()"
  },
  "api/CatchIo.Items.OffensiveThrowableItem.html": {
    "href": "api/CatchIo.Items.OffensiveThrowableItem.html",
    "title": "Class OffensiveThrowableItem | Catch.io Developer Reference",
    "keywords": "Class OffensiveThrowableItem Base class for offensive throwable items. This class causes damage if the other player hitted. Inheritance Object Item ThrowableItem OffensiveThrowableItem Stone Implements IThrowable Inherited Members ThrowableItem.GravityMultiplier ThrowableItem.ThrowResolution ThrowableItem.IsOnFloor ThrowableItem.TrajectoryPath ThrowableItem.Rigid2D ThrowableItem.CurrentTrajectoryArc ThrowableItem.HasLanded ThrowableItem.PassedPeak ThrowableItem.ThrowedTime ThrowableItem.Start() ThrowableItem.FixedUpdate() ThrowableItem.UpdateProjectilePhysic(Vector2, Vector2, Single, Single) ThrowableItem.OnThrow() ThrowableItem.OnLanded() ThrowableItem.OnPickup(Character) ThrowableItem.OnBeforeThrow(Vector2, Vector2) ThrowableItem.GetPeakHeight() Item.Owner Item.Sprite Item.OnDiscard() Item.CanPickup() Namespace : CatchIo.Items Assembly : cs.temp.dll.dll Syntax public abstract class OffensiveThrowableItem : ThrowableItem, IThrowable Properties DamageVal Declaration public abstract float DamageVal { get; } Property Value Type Description Single Methods OnHit(IDamageable) Declaration public virtual void OnHit(IDamageable other) Parameters Type Name Description IDamageable other Implements IThrowable"
  },
  "api/CatchIo.Items.StaminaPotion.html": {
    "href": "api/CatchIo.Items.StaminaPotion.html",
    "title": "Class StaminaPotion | Catch.io Developer Reference",
    "keywords": "Class StaminaPotion This class recovers by HealVal the character when used by the player. Inheritance Object Item ConsumableItem StaminaPotion Inherited Members Item.Owner Item.Sprite Item.Start() Item.CanPickup() Namespace : CatchIo.Items Assembly : cs.temp.dll.dll Syntax public class StaminaPotion : ConsumableItem Properties HealVal Declaration public float HealVal { get; } Property Value Type Description Single Methods Consume() Declaration public override void Consume() Overrides ConsumableItem.Consume() OnDiscard() Declaration public override void OnDiscard() Overrides Item.OnDiscard() OnPickup(Character) Declaration public override void OnPickup(Character owner) Parameters Type Name Description Character owner Overrides Item.OnPickup(Character)"
  },
  "api/CatchIo.Items.Stone.html": {
    "href": "api/CatchIo.Items.Stone.html",
    "title": "Class Stone | Catch.io Developer Reference",
    "keywords": "Class Stone High-level implementation for the stone object. Inheritance Object Item ThrowableItem OffensiveThrowableItem Stone Implements IThrowable Inherited Members OffensiveThrowableItem.OnHit(IDamageable) ThrowableItem.GravityMultiplier ThrowableItem.ThrowResolution ThrowableItem.IsOnFloor ThrowableItem.TrajectoryPath ThrowableItem.Rigid2D ThrowableItem.CurrentTrajectoryArc ThrowableItem.HasLanded ThrowableItem.PassedPeak ThrowableItem.ThrowedTime ThrowableItem.GetPeakHeight() Item.Owner Item.Sprite Namespace : CatchIo.Items Assembly : cs.temp.dll.dll Syntax public class Stone : OffensiveThrowableItem, IThrowable Properties DamageVal Declaration public override float DamageVal { get; } Property Value Type Description Single Overrides OffensiveThrowableItem.DamageVal Methods CanPickup() Declaration public override bool CanPickup() Returns Type Description Boolean Overrides Item.CanPickup() FixedUpdate() Declaration protected override void FixedUpdate() Overrides ThrowableItem.FixedUpdate() OnBeforeThrow(Vector2, Vector2) Declaration public override void OnBeforeThrow(Vector2 throwPos, Vector2 targetPos) Parameters Type Name Description Vector2 throwPos Vector2 targetPos Overrides ThrowableItem.OnBeforeThrow(Vector2, Vector2) OnDiscard() Declaration public override void OnDiscard() Overrides Item.OnDiscard() OnLanded() Declaration public override void OnLanded() Overrides ThrowableItem.OnLanded() OnPickup(Character) Declaration public override void OnPickup(Character owner) Parameters Type Name Description Character owner Overrides ThrowableItem.OnPickup(Character) OnThrow() Declaration public override void OnThrow() Overrides ThrowableItem.OnThrow() Start() Declaration protected override void Start() Overrides ThrowableItem.Start() UpdateProjectilePhysic(Vector2, Vector2, Single, Single) Declaration public override void UpdateProjectilePhysic(Vector2 throwPos, Vector2 targetPos, float throwRadius, float maxThrowHeight) Parameters Type Name Description Vector2 throwPos Vector2 targetPos Single throwRadius Single maxThrowHeight Overrides ThrowableItem.UpdateProjectilePhysic(Vector2, Vector2, Single, Single) Implements IThrowable"
  },
  "api/CatchIo.Items.TeleportRune.html": {
    "href": "api/CatchIo.Items.TeleportRune.html",
    "title": "Class TeleportRune | Catch.io Developer Reference",
    "keywords": "Class TeleportRune This class can teleport to item landed position with teleport dissolve effect. Inheritance Object Item ThrowableItem EvasiveThrowableItem TeleportRune Implements IThrowable IEffectPlayable Inherited Members ThrowableItem.GravityMultiplier ThrowableItem.ThrowResolution ThrowableItem.IsOnFloor ThrowableItem.TrajectoryPath ThrowableItem.Rigid2D ThrowableItem.CurrentTrajectoryArc ThrowableItem.HasLanded ThrowableItem.PassedPeak ThrowableItem.ThrowedTime ThrowableItem.GetPeakHeight() Item.Owner Item.Sprite Namespace : CatchIo.Items Assembly : cs.temp.dll.dll Syntax public class TeleportRune : EvasiveThrowableItem, IThrowable, IEffectPlayable Fields TeleportDissolve Declaration public DissolveEffeect TeleportDissolve Field Value Type Description DissolveEffeect Methods CanPickup() Declaration public override bool CanPickup() Returns Type Description Boolean Overrides Item.CanPickup() EffectEndSequence() Declaration public IEnumerator EffectEndSequence() Returns Type Description IEnumerator EffectSequence() Declaration public IEnumerator EffectSequence() Returns Type Description IEnumerator ExecuteEffect() Declaration public void ExecuteEffect() FixedUpdate() Declaration protected override void FixedUpdate() Overrides ThrowableItem.FixedUpdate() OnBeforeThrow(Vector2, Vector2) Declaration public override void OnBeforeThrow(Vector2 throwPos, Vector2 targetPos) Parameters Type Name Description Vector2 throwPos Vector2 targetPos Overrides ThrowableItem.OnBeforeThrow(Vector2, Vector2) OnDiscard() Declaration public override void OnDiscard() Overrides Item.OnDiscard() OnEndEffect() Declaration public void OnEndEffect() OnLanded() Declaration public override void OnLanded() Overrides ThrowableItem.OnLanded() OnPickup(Character) Declaration public override void OnPickup(Character owner) Parameters Type Name Description Character owner Overrides ThrowableItem.OnPickup(Character) OnThrow() Declaration public override void OnThrow() Overrides ThrowableItem.OnThrow() Start() Declaration protected override void Start() Overrides ThrowableItem.Start() UpdateProjectilePhysic(Vector2, Vector2, Single, Single) Declaration public override void UpdateProjectilePhysic(Vector2 throwPos, Vector2 targetPos, float throwRadius, float maxThrowHeight) Parameters Type Name Description Vector2 throwPos Vector2 targetPos Single throwRadius Single maxThrowHeight Overrides ThrowableItem.UpdateProjectilePhysic(Vector2, Vector2, Single, Single) Implements IThrowable IEffectPlayable"
  },
  "api/CatchIo.Items.ThrowableItem.html": {
    "href": "api/CatchIo.Items.ThrowableItem.html",
    "title": "Class ThrowableItem | Catch.io Developer Reference",
    "keywords": "Class ThrowableItem Base class for all throwable items. If player throwed this object, it will be placed to mouse-position. Inheritance Object Item ThrowableItem EvasiveThrowableItem OffensiveThrowableItem Implements IThrowable Inherited Members Item.Owner Item.Sprite Item.OnDiscard() Item.CanPickup() Namespace : CatchIo.Items Assembly : cs.temp.dll.dll Syntax public abstract class ThrowableItem : Item, IThrowable Fields CurrentTrajectoryArc Declaration protected TrajectoryArc CurrentTrajectoryArc Field Value Type Description TrajectoryArc GravityMultiplier Declaration protected readonly float GravityMultiplier Field Value Type Description Single HasLanded Declaration protected bool HasLanded Field Value Type Description Boolean PassedPeak Declaration protected bool PassedPeak Field Value Type Description Boolean Rigid2D Declaration protected Rigidbody2D Rigid2D Field Value Type Description Rigidbody2D ThrowedTime Declaration protected float ThrowedTime Field Value Type Description Single ThrowResolution Declaration protected readonly int ThrowResolution Field Value Type Description Int32 Properties IsOnFloor Declaration public bool IsOnFloor { get; } Property Value Type Description Boolean TrajectoryPath Declaration public Vector3[] TrajectoryPath { get; } Property Value Type Description Vector3 [] Methods FixedUpdate() Declaration protected virtual void FixedUpdate() GetPeakHeight() Declaration protected float GetPeakHeight() Returns Type Description Single OnBeforeThrow(Vector2, Vector2) Declaration public abstract void OnBeforeThrow(Vector2 throwPos, Vector2 targetPos) Parameters Type Name Description Vector2 throwPos Vector2 targetPos OnLanded() Declaration public virtual void OnLanded() OnPickup(Character) Declaration public override void OnPickup(Character owner) Parameters Type Name Description Character owner Overrides Item.OnPickup(Character) OnThrow() Declaration public virtual void OnThrow() Start() Declaration protected override void Start() Overrides Item.Start() UpdateProjectilePhysic(Vector2, Vector2, Single, Single) Declaration public virtual void UpdateProjectilePhysic(Vector2 throwPos, Vector2 targetPos, float throwRadius, float maxThrowHeight) Parameters Type Name Description Vector2 throwPos Vector2 targetPos Single throwRadius Single maxThrowHeight Implements IThrowable"
  },
  "api/CatchIo.Menus.GameManager.html": {
    "href": "api/CatchIo.Menus.GameManager.html",
    "title": "Class GameManager | Catch.io Developer Reference",
    "keywords": "Class GameManager The game manager script that is used to handle various tasks when the game starts. Such tasks includes local player instance management, platform controller management, in-game network management, etc. Inheritance Object GameManager Namespace : CatchIo.Menus Assembly : cs.temp.dll.dll Syntax public class GameManager : NetworkCallback Fields PlayerCamera The game camera that should be instantiated in the game scene. Declaration public GameObject PlayerCamera Field Value Type Description GameObject PlayerPrefab The player prefab to instantiate in the game scene. Declaration public GameObject PlayerPrefab Field Value Type Description GameObject Properties CurrentTilemapContainer Tilemap container reference for the current game scene. Declaration public static TilemapContainer CurrentTilemapContainer { get; } Property Value Type Description TilemapContainer IsMobile Returns true if the current device should use mobile controls. Declaration public static bool IsMobile { get; } Property Value Type Description Boolean LocalPlayerInst The local player instance. This is generally the same as the local player instance provided by Photon Network. Declaration public static Character LocalPlayerInst { get; } Property Value Type Description Character Methods OnLeftRoom() Called when the local player left the room. We need to load the launcher scene. Declaration public override void OnLeftRoom() OnPlayerEnteredRoom(Photon.Realtime.Player) Declaration public override void OnPlayerEnteredRoom(Photon.Realtime.Player newPlayer) Parameters Type Name Description Photon.Realtime.Player newPlayer OnPlayerLeftRoom(Photon.Realtime.Player) Declaration public override void OnPlayerLeftRoom(Photon.Realtime.Player otherPlayer) Parameters Type Name Description Photon.Realtime.Player otherPlayer"
  },
  "api/CatchIo.Menus.html": {
    "href": "api/CatchIo.Menus.html",
    "title": "Namespace CatchIo.Menus | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Menus Classes GameManager The game manager script that is used to handle various tasks when the game starts. Such tasks includes local player instance management, platform controller management, in-game network management, etc. Launcher The entry point for establishing a connection between the player and the master server. This script will handle the menu GUI logic as well. NetworkLobbyManager Photon lobby scene manager. All the lobby logic and network management should be handled from here."
  },
  "api/CatchIo.Menus.Launcher.html": {
    "href": "api/CatchIo.Menus.Launcher.html",
    "title": "Class Launcher | Catch.io Developer Reference",
    "keywords": "Class Launcher The entry point for establishing a connection between the player and the master server. This script will handle the menu GUI logic as well. Inheritance Object Launcher Namespace : CatchIo.Menus Assembly : cs.temp.dll.dll Syntax public class Launcher : NetworkCallback Methods OnClick_Login() Connect the user to Photon when they click the login button Declaration public void OnClick_Login() OnConnectedToMaster() Declaration public override void OnConnectedToMaster() OnDisconnected(DisconnectCause) Declaration public override void OnDisconnected(DisconnectCause cause) Parameters Type Name Description DisconnectCause cause OnJoinedLobby() Declaration public override void OnJoinedLobby()"
  },
  "api/CatchIo.Menus.NetworkLobbyManager.html": {
    "href": "api/CatchIo.Menus.NetworkLobbyManager.html",
    "title": "Class NetworkLobbyManager | Catch.io Developer Reference",
    "keywords": "Class NetworkLobbyManager Photon lobby scene manager. All the lobby logic and network management should be handled from here. Inheritance Object NetworkLobbyManager Namespace : CatchIo.Menus Assembly : cs.temp.dll.dll Syntax public class NetworkLobbyManager : NetworkCallback Fields Instance A static reference to itself. This is used to make this object a singleton for the lobby. Declaration public static GameObject Instance Field Value Type Description GameObject Methods CreateRoom(String, String, Byte) Create a new room from the given parameter. The map name will be stored as a custom metadata for room data in photon network. Declaration public void CreateRoom(string roomName, string mapName, byte maxPlayer) Parameters Type Name Description String roomName String mapName Byte maxPlayer JoinRoom(String) Joins the room with the given name. The actual scene loading is handled by the pun callback method. Declaration public void JoinRoom(string roomName) Parameters Type Name Description String roomName OnCreatedRoom() Declaration public override void OnCreatedRoom() OnJoinedRoom() Declaration public override void OnJoinedRoom() OnJoinRoomFailed(Int16, String) Declaration public override void OnJoinRoomFailed(short returnCode, string message) Parameters Type Name Description Int16 returnCode String message OnRoomListUpdate(List<RoomInfo>) Declaration public override void OnRoomListUpdate(List<RoomInfo> roomList) Parameters Type Name Description List < RoomInfo > roomList"
  },
  "api/CatchIo.ObjectPool.Footprint.FootprintSprite.html": {
    "href": "api/CatchIo.ObjectPool.Footprint.FootprintSprite.html",
    "title": "Struct Footprint.FootprintSprite | Catch.io Developer Reference",
    "keywords": "Struct Footprint.FootprintSprite Namespace : CatchIo.ObjectPool Assembly : cs.temp.dll.dll Syntax public struct FootprintSprite Fields Sprite Declaration public Sprite Sprite Field Value Type Description Sprite Surface Declaration public Surface.SurfaceType Surface Field Value Type Description Surface.SurfaceType"
  },
  "api/CatchIo.ObjectPool.Footprint.html": {
    "href": "api/CatchIo.ObjectPool.Footprint.html",
    "title": "Class Footprint | Catch.io Developer Reference",
    "keywords": "Class Footprint The footprint component for the footprint game object. Inheritance Object Footprint Namespace : CatchIo.ObjectPool Assembly : cs.temp.dll.dll Syntax public class Footprint : MonoBehaviour Methods HandleSpawn() Declaration public void HandleSpawn() Initialize() Declaration public void Initialize()"
  },
  "api/CatchIo.ObjectPool.html": {
    "href": "api/CatchIo.ObjectPool.html",
    "title": "Namespace CatchIo.ObjectPool | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.ObjectPool Classes Footprint The footprint component for the footprint game object. PurePoolManager The main object pool manager that implements the package Pure Pool. Structs Footprint.FootprintSprite"
  },
  "api/CatchIo.ObjectPool.PurePoolManager.html": {
    "href": "api/CatchIo.ObjectPool.PurePoolManager.html",
    "title": "Class PurePoolManager | Catch.io Developer Reference",
    "keywords": "Class PurePoolManager The main object pool manager that implements the package Pure Pool. Inheritance Object PurePoolManager Namespace : CatchIo.ObjectPool Assembly : cs.temp.dll.dll Syntax public class PurePoolManager : MonoBehaviour Fields Instance A static reference to itself used for the singleton pattern. Declaration public static PurePoolManager Instance Field Value Type Description PurePoolManager Methods AcquireFootprint(Vector3, Quaternion) Declaration public GameObject AcquireFootprint(Vector3 position, Quaternion rotation) Parameters Type Name Description Vector3 position Quaternion rotation Returns Type Description GameObject ReleasePool(GameObject) Declaration public void ReleasePool(GameObject obj) Parameters Type Name Description GameObject obj"
  },
  "api/CatchIo.PlayerCharacter.Character.html": {
    "href": "api/CatchIo.PlayerCharacter.Character.html",
    "title": "Class Character | Catch.io Developer Reference",
    "keywords": "Class Character Base class for all character data control. Inheritance Object Character Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public class Character : MonoBehaviourPun Fields ActionState Declaration public CharacterActionState ActionState Field Value Type Description CharacterActionState AddItemToInventoryAction Declaration public Action<Item> AddItemToInventoryAction Field Value Type Description Action < Item > MaxThrowHeight Declaration public float MaxThrowHeight Field Value Type Description Single MoveState Declaration public CharacterMoveState MoveState Field Value Type Description CharacterMoveState RemoveHoldingItemAction Declaration public Action RemoveHoldingItemAction Field Value Type Description Action RunningSpeed Declaration public float RunningSpeed Field Value Type Description Single SneakingSpeed Declaration public float SneakingSpeed Field Value Type Description Single ThrowRadius Declaration public float ThrowRadius Field Value Type Description Single WalkingSpeed Declaration public float WalkingSpeed Field Value Type Description Single Properties CanBeKilled Declaration public bool CanBeKilled { get; } Property Value Type Description Boolean CanControl Declaration public bool CanControl { get; } Property Value Type Description Boolean CharacterSkin Declaration public CharacterSkin CharacterSkin { get; } Property Value Type Description CharacterSkin CurrentViewAngle Declaration public float CurrentViewAngle { get; } Property Value Type Description Single HoldingItem Declaration public Item HoldingItem { get; set; } Property Value Type Description Item MeleeDamage Declaration public float MeleeDamage { get; } Property Value Type Description Single Name Declaration public string Name { get; } Property Value Type Description String SanityVal Declaration public float SanityVal { get; } Property Value Type Description Single StaminaVal Declaration public float StaminaVal { get; } Property Value Type Description Single Methods Attack(IDamageable) Declaration public void Attack(IDamageable player) Parameters Type Name Description IDamageable player ConsumeItem(ConsumableItem) Declaration public void ConsumeItem(ConsumableItem item) Parameters Type Name Description ConsumableItem item DiscardHoldingItem() Declaration public void DiscardHoldingItem() Draw() Declaration public void Draw() HealStamina(Single) Declaration public void HealStamina(float healVal) Parameters Type Name Description Single healVal Look(Int32) Declaration public void Look(int viewAngle) Parameters Type Name Description Int32 viewAngle Move(Vector2, Boolean, Boolean) Declaration public void Move(Vector2 moveDir, bool isRunning, bool isCrouching) Parameters Type Name Description Vector2 moveDir Boolean isRunning Boolean isCrouching PickupItem(Item) Declaration public void PickupItem(Item item) Parameters Type Name Description Item item ResetActionState() Declaration public void ResetActionState() TakeDamage(Single) Declaration public void TakeDamage(float damage) Parameters Type Name Description Single damage ThrowItem(ThrowableItem, Vector2) Declaration public void ThrowItem(ThrowableItem item, Vector2 targetPos) Parameters Type Name Description ThrowableItem item Vector2 targetPos"
  },
  "api/CatchIo.PlayerCharacter.CharacterActionState.html": {
    "href": "api/CatchIo.PlayerCharacter.CharacterActionState.html",
    "title": "Enum CharacterActionState | Catch.io Developer Reference",
    "keywords": "Enum CharacterActionState Enum for character action states. Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public enum CharacterActionState Fields Name Description Attack Consume Death End None Throw"
  },
  "api/CatchIo.PlayerCharacter.CharacterAnimation.html": {
    "href": "api/CatchIo.PlayerCharacter.CharacterAnimation.html",
    "title": "Class CharacterAnimation | Catch.io Developer Reference",
    "keywords": "Class CharacterAnimation This class plays player animations in animator. Inheritance Object CharacterAnimation Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public class CharacterAnimation : MonoBehaviour Methods PlayActionState(CharacterActionState) Declaration public void PlayActionState(CharacterActionState state) Parameters Type Name Description CharacterActionState state UpdateLookAnimation(Single) Declaration public void UpdateLookAnimation(float viewAngle) Parameters Type Name Description Single viewAngle UpdateMoveAnimation(CharacterMoveState) Declaration public void UpdateMoveAnimation(CharacterMoveState moveState) Parameters Type Name Description CharacterMoveState moveState"
  },
  "api/CatchIo.PlayerCharacter.CharacterController.html": {
    "href": "api/CatchIo.PlayerCharacter.CharacterController.html",
    "title": "Class CharacterController | Catch.io Developer Reference",
    "keywords": "Class CharacterController Base class for character control by player inputs. Inheritance Object CharacterController Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public class CharacterController : MonoBehaviour"
  },
  "api/CatchIo.PlayerCharacter.CharacterFOV.html": {
    "href": "api/CatchIo.PlayerCharacter.CharacterFOV.html",
    "title": "Class CharacterFOV | Catch.io Developer Reference",
    "keywords": "Class CharacterFOV This class implements the FOV light effect behavior that is controlled by the player character's view. Inheritance Object CharacterFOV Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public class CharacterFOV : MonoBehaviour Methods ToggleLight() Declaration public void ToggleLight() UpdateFOVAngle(Single) Declaration public void UpdateFOVAngle(float angle) Parameters Type Name Description Single angle"
  },
  "api/CatchIo.PlayerCharacter.CharacterHitbox.html": {
    "href": "api/CatchIo.PlayerCharacter.CharacterHitbox.html",
    "title": "Class CharacterHitbox | Catch.io Developer Reference",
    "keywords": "Class CharacterHitbox This class performs to character collider. Inheritance Object CharacterHitbox Implements IDamageable Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public class CharacterHitbox : MonoBehaviour, IDamageable Methods OnDamage(Single) Declaration public void OnDamage(float damage) Parameters Type Name Description Single damage Implements IDamageable"
  },
  "api/CatchIo.PlayerCharacter.CharacterMoveState.html": {
    "href": "api/CatchIo.PlayerCharacter.CharacterMoveState.html",
    "title": "Enum CharacterMoveState | Catch.io Developer Reference",
    "keywords": "Enum CharacterMoveState Enum for character move state. Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public enum CharacterMoveState Fields Name Description Run Sneak SneakStatic Static Walk"
  },
  "api/CatchIo.PlayerCharacter.CharacterSkin.html": {
    "href": "api/CatchIo.PlayerCharacter.CharacterSkin.html",
    "title": "Class CharacterSkin | Catch.io Developer Reference",
    "keywords": "Class CharacterSkin Base class for character skin. Inheritance Object CharacterSkin Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public class CharacterSkin Constructors CharacterSkin(Animator, Renderer) Declaration public CharacterSkin(Animator animator, Renderer renderer) Parameters Type Name Description Animator animator Renderer renderer Fields Animator Declaration public Animator Animator Field Value Type Description Animator Renderer Declaration public Renderer Renderer Field Value Type Description Renderer SkinName Declaration public string SkinName Field Value Type Description String"
  },
  "api/CatchIo.PlayerCharacter.html": {
    "href": "api/CatchIo.PlayerCharacter.html",
    "title": "Namespace CatchIo.PlayerCharacter | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.PlayerCharacter Classes Character Base class for all character data control. CharacterAnimation This class plays player animations in animator. CharacterController Base class for character control by player inputs. CharacterFOV This class implements the FOV light effect behavior that is controlled by the player character's view. CharacterHitbox This class performs to character collider. CharacterSkin Base class for character skin. Inventory This class is container for items. InventoryController This class controls what Inventory class related to. Interfaces IDamageable Interface for objects that can take damage. Object taking damage must implement the OnDamage function, and objects that gives damage should call that function and pass the damage value. Enums CharacterActionState Enum for character action states. CharacterMoveState Enum for character move state."
  },
  "api/CatchIo.PlayerCharacter.IDamageable.html": {
    "href": "api/CatchIo.PlayerCharacter.IDamageable.html",
    "title": "Interface IDamageable | Catch.io Developer Reference",
    "keywords": "Interface IDamageable Interface for objects that can take damage. Object taking damage must implement the OnDamage function, and objects that gives damage should call that function and pass the damage value. Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public interface IDamageable Methods OnDamage(Single) Declaration void OnDamage(float damage) Parameters Type Name Description Single damage"
  },
  "api/CatchIo.PlayerCharacter.Inventory.html": {
    "href": "api/CatchIo.PlayerCharacter.Inventory.html",
    "title": "Class Inventory | Catch.io Developer Reference",
    "keywords": "Class Inventory This class is container for items. Inheritance Object Inventory Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public class Inventory Constructors Inventory(InventoryHUD, Int32) Declaration public Inventory(InventoryHUD hud, int maxInventorySize = 5) Parameters Type Name Description InventoryHUD hud Int32 maxInventorySize Methods AddItem(Item) Declaration public void AddItem(Item newItem) Parameters Type Name Description Item newItem Draw() Declaration public void Draw() GetCount() Declaration public int GetCount() Returns Type Description Int32 GetItem(Int32) Declaration public Item GetItem(int slotNo) Parameters Type Name Description Int32 slotNo Returns Type Description Item IsEmpty() Declaration public bool IsEmpty() Returns Type Description Boolean IsFull() Declaration public bool IsFull() Returns Type Description Boolean RemoveItem(Int32) Declaration public void RemoveItem(int slotNo) Parameters Type Name Description Int32 slotNo ToArray() Declaration public Item[] ToArray() Returns Type Description Item []"
  },
  "api/CatchIo.PlayerCharacter.InventoryController.html": {
    "href": "api/CatchIo.PlayerCharacter.InventoryController.html",
    "title": "Class InventoryController | Catch.io Developer Reference",
    "keywords": "Class InventoryController This class controls what Inventory class related to. Inheritance Object InventoryController Namespace : CatchIo.PlayerCharacter Assembly : cs.temp.dll.dll Syntax public class InventoryController : MonoBehaviour Properties CurrentIndex Declaration public int CurrentIndex { get; } Property Value Type Description Int32 Inventory Declaration public Inventory Inventory { get; } Property Value Type Description Inventory Methods Clear() Declaration public void Clear() Draw() Declaration public void Draw() SelectItem(Int32) Declaration public void SelectItem(int inputInvIndex) Parameters Type Name Description Int32 inputInvIndex Start() Declaration public void Start() Update() Unity update function (runs every frame) Declaration public void Update()"
  },
  "api/CatchIo.ProjectileMotion.html": {
    "href": "api/CatchIo.ProjectileMotion.html",
    "title": "Namespace CatchIo.ProjectileMotion | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.ProjectileMotion Classes TrajectoryArc This class contains to projectile motion data. Interfaces IThrowable Interface for throwable items."
  },
  "api/CatchIo.ProjectileMotion.IThrowable.html": {
    "href": "api/CatchIo.ProjectileMotion.IThrowable.html",
    "title": "Interface IThrowable | Catch.io Developer Reference",
    "keywords": "Interface IThrowable Interface for throwable items. Namespace : CatchIo.ProjectileMotion Assembly : cs.temp.dll.dll Syntax public interface IThrowable Properties IsOnFloor Declaration bool IsOnFloor { get; } Property Value Type Description Boolean Methods OnBeforeThrow(Vector2, Vector2) Declaration void OnBeforeThrow(Vector2 throwPos, Vector2 targetPos) Parameters Type Name Description Vector2 throwPos Vector2 targetPos OnLanded() Declaration void OnLanded() UpdateProjectilePhysic(Vector2, Vector2, Single, Single) Declaration void UpdateProjectilePhysic(Vector2 throwPos, Vector2 targetPos, float throwRadius, float maxThrowHeight) Parameters Type Name Description Vector2 throwPos Vector2 targetPos Single throwRadius Single maxThrowHeight"
  },
  "api/CatchIo.ProjectileMotion.TrajectoryArc.html": {
    "href": "api/CatchIo.ProjectileMotion.TrajectoryArc.html",
    "title": "Class TrajectoryArc | Catch.io Developer Reference",
    "keywords": "Class TrajectoryArc This class contains to projectile motion data. Inheritance Object TrajectoryArc Namespace : CatchIo.ProjectileMotion Assembly : cs.temp.dll.dll Syntax public class TrajectoryArc Constructors TrajectoryArc() Declaration public TrajectoryArc() TrajectoryArc(Vector3, Single, Vector3[]) Declaration public TrajectoryArc(Vector3 initalVelocity, float timeToTarget, Vector3[] trajectoryPath) Parameters Type Name Description Vector3 initalVelocity Single timeToTarget Vector3 [] trajectoryPath Fields InitalVelocity Declaration public Vector3 InitalVelocity Field Value Type Description Vector3 TimeToTarget Declaration public float TimeToTarget Field Value Type Description Single TrajectoryPath Declaration public Vector3[] TrajectoryPath Field Value Type Description Vector3 [] Methods GetFinalPosition() Declaration public Vector3 GetFinalPosition() Returns Type Description Vector3 UpdateTrajectoryArc(Vector3, Single, Vector3[]) Declaration public void UpdateTrajectoryArc(Vector3 initalVelocity, float timeToTarget, Vector3[] trajectoryPath) Parameters Type Name Description Vector3 initalVelocity Single timeToTarget Vector3 [] trajectoryPath"
  },
  "api/CatchIo.Sound.html": {
    "href": "api/CatchIo.Sound.html",
    "title": "Namespace CatchIo.Sound | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Sound Classes SoundManager"
  },
  "api/CatchIo.Sound.SoundManager.html": {
    "href": "api/CatchIo.Sound.SoundManager.html",
    "title": "Class SoundManager | Catch.io Developer Reference",
    "keywords": "Class SoundManager Inheritance Object SoundManager Namespace : CatchIo.Sound Assembly : cs.temp.dll.dll Syntax public class SoundManager : SingletonMonoBehaviour<SoundManager> Fields SurfaceSound Declaration public string SurfaceSound Field Value Type Description String Methods PlaySurfaceSFX(Transform, Single) Declaration public void PlaySurfaceSFX(Transform origin, float volume = 2F) Parameters Type Name Description Transform origin Single volume"
  },
  "api/CatchIo.UI.CatchButtonEnable.html": {
    "href": "api/CatchIo.UI.CatchButtonEnable.html",
    "title": "Class CatchButtonEnable | Catch.io Developer Reference",
    "keywords": "Class CatchButtonEnable Inheritance Object CatchButtonEnable Implements ICallback Namespace : CatchIo.UI Assembly : cs.temp.dll.dll Syntax public class CatchButtonEnable : MonoBehaviour, ICallback Methods Invoke() Declaration public void Invoke() Implements ICallback"
  },
  "api/CatchIo.UI.html": {
    "href": "api/CatchIo.UI.html",
    "title": "Namespace CatchIo.UI | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.UI Classes CatchButtonEnable InventoryHUD This class for displaying Inventory HUD. InventorySlot This class for controlling inventory slot. LobbyRoomsView View controller for the game lobby menu. This class will only expose the GUI methods and controls for the scene to render. The actual logic of all this is handled by the lobby manager script. RoomItemControl A GUI controller script for displaying Photon rooms RotateJoystick StaminaBar"
  },
  "api/CatchIo.UI.InventoryHUD.html": {
    "href": "api/CatchIo.UI.InventoryHUD.html",
    "title": "Class InventoryHUD | Catch.io Developer Reference",
    "keywords": "Class InventoryHUD This class for displaying Inventory HUD. Inheritance Object InventoryHUD Namespace : CatchIo.UI Assembly : cs.temp.dll.dll Syntax public class InventoryHUD : GuiBehavior Fields Arrow Declaration public Transform Arrow Field Value Type Description Transform SelectSlotSize Declaration public int SelectSlotSize Field Value Type Description Int32 Slots Declaration public Transform Slots Field Value Type Description Transform Methods AddItem(Sprite) Declaration public void AddItem(Sprite itemSprite) Parameters Type Name Description Sprite itemSprite RemoveItem(Int32) Declaration public void RemoveItem(int index) Parameters Type Name Description Int32 index SelectItemHUD(Int32) Declaration public void SelectItemHUD(int index) Parameters Type Name Description Int32 index Start() Declaration public void Start()"
  },
  "api/CatchIo.UI.InventorySlot.html": {
    "href": "api/CatchIo.UI.InventorySlot.html",
    "title": "Class InventorySlot | Catch.io Developer Reference",
    "keywords": "Class InventorySlot This class for controlling inventory slot. Inheritance Object InventorySlot Namespace : CatchIo.UI Assembly : cs.temp.dll.dll Syntax public class InventorySlot : GuiBehavior Fields IsExistItem Declaration public bool IsExistItem Field Value Type Description Boolean ItemImage Declaration public Image ItemImage Field Value Type Description Image SlotImage Declaration public Image SlotImage Field Value Type Description Image Methods AddItem(Sprite) Declaration public void AddItem(Sprite itemSprite) Parameters Type Name Description Sprite itemSprite Release() Declaration public void Release() RemoveItem() Declaration public void RemoveItem() Select(Int32) Declaration public void Select(int size) Parameters Type Name Description Int32 size Start() Declaration public void Start()"
  },
  "api/CatchIo.UI.LobbyRoomsView.html": {
    "href": "api/CatchIo.UI.LobbyRoomsView.html",
    "title": "Class LobbyRoomsView | Catch.io Developer Reference",
    "keywords": "Class LobbyRoomsView View controller for the game lobby menu. This class will only expose the GUI methods and controls for the scene to render. The actual logic of all this is handled by the lobby manager script. Inheritance Object LobbyRoomsView Namespace : CatchIo.UI Assembly : cs.temp.dll.dll Syntax public class LobbyRoomsView : GuiBehavior Properties NewRoomMap Declaration public string NewRoomMap { get; } Property Value Type Description String NewRoomMaxPlayer Declaration public int NewRoomMaxPlayer { get; } Property Value Type Description Int32 NewRoomName Declaration public string NewRoomName { get; } Property Value Type Description String Methods AddRoomRender(RoomInfo) Declaration public void AddRoomRender(RoomInfo room) Parameters Type Name Description RoomInfo room DisplayLogMessage(String, Color) Declaration public void DisplayLogMessage(string message, Color color) Parameters Type Name Description String message Color color OnChange_MapDropdown() Declaration public void OnChange_MapDropdown() OnChange_MaxSlider() Declaration public void OnChange_MaxSlider() OnChange_RoomNameInput() Declaration public void OnChange_RoomNameInput() OnClick_CloseCreateRoomPanel() Declaration public void OnClick_CloseCreateRoomPanel() OnClick_CreateRoomButton() Declaration public void OnClick_CreateRoomButton() OnClick_OpenCreateRoomPanel() Declaration public void OnClick_OpenCreateRoomPanel() RemoveRoomRender(RoomInfo) Declaration public void RemoveRoomRender(RoomInfo room) Parameters Type Name Description RoomInfo room SetInitialRoomData() Declaration public void SetInitialRoomData() SetLoadableScenes(List<String>) Declaration public void SetLoadableScenes(List<string> playableList) Parameters Type Name Description List < String > playableList SetPlayerNameLabel(String) Declaration public void SetPlayerNameLabel(string name) Parameters Type Name Description String name"
  },
  "api/CatchIo.UI.RoomItemControl.html": {
    "href": "api/CatchIo.UI.RoomItemControl.html",
    "title": "Class RoomItemControl | Catch.io Developer Reference",
    "keywords": "Class RoomItemControl A GUI controller script for displaying Photon rooms Inheritance Object RoomItemControl Namespace : CatchIo.UI Assembly : cs.temp.dll.dll Syntax public class RoomItemControl : GuiBehavior Properties RoomName Declaration public string RoomName { get; } Property Value Type Description String Methods CreateRoomRender(RoomInfo) Declaration public void CreateRoomRender(RoomInfo room) Parameters Type Name Description RoomInfo room OnClick_JoinRoom() Declaration public void OnClick_JoinRoom()"
  },
  "api/CatchIo.UI.RotateJoystick.html": {
    "href": "api/CatchIo.UI.RotateJoystick.html",
    "title": "Class RotateJoystick | Catch.io Developer Reference",
    "keywords": "Class RotateJoystick Inheritance Object RotateJoystick Namespace : CatchIo.UI Assembly : cs.temp.dll.dll Syntax public class RotateJoystick : UnityStandardAssets.CrossPlatformInput.Joystick Methods Start() Declaration public override void Start()"
  },
  "api/CatchIo.UI.StaminaBar.html": {
    "href": "api/CatchIo.UI.StaminaBar.html",
    "title": "Class StaminaBar | Catch.io Developer Reference",
    "keywords": "Class StaminaBar Inheritance Object StaminaBar Namespace : CatchIo.UI Assembly : cs.temp.dll.dll Syntax public class StaminaBar : GuiBehavior Fields HealthBarCorrection Declaration public float HealthBarCorrection Field Value Type Description Single StaminaSliderPrefab Declaration public GameObject StaminaSliderPrefab Field Value Type Description GameObject Methods ControlStaminaBar() Declaration public void ControlStaminaBar() ControlStaminaBarPosition() Declaration public void ControlStaminaBarPosition()"
  },
  "api/CatchIo.Util.EditorGameLoader.html": {
    "href": "api/CatchIo.Util.EditorGameLoader.html",
    "title": "Class EditorGameLoader | Catch.io Developer Reference",
    "keywords": "Class EditorGameLoader One-time utility component that adds the manager scene and the UI scene to the current game scene and destroys itself. Inheritance Object EditorGameLoader Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax public class EditorGameLoader : MonoBehaviour"
  },
  "api/CatchIo.Util.ExtensionMethods.html": {
    "href": "api/CatchIo.Util.ExtensionMethods.html",
    "title": "Class ExtensionMethods | Catch.io Developer Reference",
    "keywords": "Class ExtensionMethods Inheritance Object ExtensionMethods Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax public static class ExtensionMethods Methods toVector2(Vector3) Declaration public static Vector2 toVector2(this Vector3 vec3) Parameters Type Name Description Vector3 vec3 Returns Type Description Vector2 toVector3(Vector2) Declaration public static Vector3 toVector3(this Vector2 vec2) Parameters Type Name Description Vector2 vec2 Returns Type Description Vector3"
  },
  "api/CatchIo.Util.FloorTilemaps.html": {
    "href": "api/CatchIo.Util.FloorTilemaps.html",
    "title": "Class FloorTilemaps | Catch.io Developer Reference",
    "keywords": "Class FloorTilemaps Inheritance Object FloorTilemaps Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax [Serializable] public class FloorTilemaps Fields Tilemaps Declaration public List<Tilemap> Tilemaps Field Value Type Description List < Tilemap >"
  },
  "api/CatchIo.Util.GetTilemapAndTileBase.html": {
    "href": "api/CatchIo.Util.GetTilemapAndTileBase.html",
    "title": "Class GetTilemapAndTileBase | Catch.io Developer Reference",
    "keywords": "Class GetTilemapAndTileBase Set of static methods for obtaining tilemap information for determining what tile the player is standing on. This only works with Unity tile map. We need to implement this for SuperTilemapEditor as well. Inheritance Object GetTilemapAndTileBase Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax public static class GetTilemapAndTileBase Fields TILE_MAP_TAG Declaration public static string TILE_MAP_TAG Field Value Type Description String Methods GetStandingTile(Vector3) Declaration public static TileBase GetStandingTile(Vector3 position) Parameters Type Name Description Vector3 position Returns Type Description TileBase"
  },
  "api/CatchIo.Util.html": {
    "href": "api/CatchIo.Util.html",
    "title": "Namespace CatchIo.Util | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Util Classes EditorGameLoader One-time utility component that adds the manager scene and the UI scene to the current game scene and destroys itself. ExtensionMethods FloorTilemaps GetTilemapAndTileBase Set of static methods for obtaining tilemap information for determining what tile the player is standing on. This only works with Unity tile map. We need to implement this for SuperTilemapEditor as well. Math SceneControl Singleton<T> SingletonMonoBehaviour<T> TileInfo TilemapContainer"
  },
  "api/CatchIo.Util.Math.html": {
    "href": "api/CatchIo.Util.Math.html",
    "title": "Class Math | Catch.io Developer Reference",
    "keywords": "Class Math Inheritance Object Math Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax public static class Math Methods IsNaNVector(Vector2) Declaration public static bool IsNaNVector(Vector2 vector2) Parameters Type Name Description Vector2 vector2 Returns Type Description Boolean"
  },
  "api/CatchIo.Util.ObserverPattern.html": {
    "href": "api/CatchIo.Util.ObserverPattern.html",
    "title": "Namespace CatchIo.Util.ObserverPattern | Catch.io Developer Reference",
    "keywords": "Namespace CatchIo.Util.ObserverPattern Classes Subject Interfaces ICallback"
  },
  "api/CatchIo.Util.ObserverPattern.ICallback.html": {
    "href": "api/CatchIo.Util.ObserverPattern.ICallback.html",
    "title": "Interface ICallback | Catch.io Developer Reference",
    "keywords": "Interface ICallback Namespace : CatchIo.Util.ObserverPattern Assembly : cs.temp.dll.dll Syntax public interface ICallback Methods Invoke() Declaration void Invoke()"
  },
  "api/CatchIo.Util.ObserverPattern.Subject.html": {
    "href": "api/CatchIo.Util.ObserverPattern.Subject.html",
    "title": "Class Subject | Catch.io Developer Reference",
    "keywords": "Class Subject Inheritance Object Subject Namespace : CatchIo.Util.ObserverPattern Assembly : cs.temp.dll.dll Syntax public class Subject Methods AddObserver(ICallback) Declaration public void AddObserver(ICallback callback) Parameters Type Name Description ICallback callback Clear() Declaration public void Clear() RemoveObserver(ICallback) Declaration public void RemoveObserver(ICallback callback) Parameters Type Name Description ICallback callback SignalCallback() Declaration public void SignalCallback()"
  },
  "api/CatchIo.Util.SceneControl.html": {
    "href": "api/CatchIo.Util.SceneControl.html",
    "title": "Class SceneControl | Catch.io Developer Reference",
    "keywords": "Class SceneControl Inheritance Object SceneControl Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax public static class SceneControl Methods Load(String, LoadSceneMode) Synchronous SceneManager.LoadScene() wrapper Declaration public static void Load(string sceneName, LoadSceneMode mode = null) Parameters Type Name Description String sceneName LoadSceneMode mode UnloadAdditive(String) Declaration public static void UnloadAdditive(string sceneName) Parameters Type Name Description String sceneName"
  },
  "api/CatchIo.Util.Singleton-1.html": {
    "href": "api/CatchIo.Util.Singleton-1.html",
    "title": "Class Singleton<T> | Catch.io Developer Reference",
    "keywords": "Class Singleton<T> Inheritance Object Singleton<T> Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax public class Singleton<T> where T : class Type Parameters Name Description T Properties Instance Declaration public static T Instance { get; } Property Value Type Description T"
  },
  "api/CatchIo.Util.SingletonMonoBehaviour-1.html": {
    "href": "api/CatchIo.Util.SingletonMonoBehaviour-1.html",
    "title": "Class SingletonMonoBehaviour<T> | Catch.io Developer Reference",
    "keywords": "Class SingletonMonoBehaviour<T> Inheritance Object SingletonMonoBehaviour<T> Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax public abstract class SingletonMonoBehaviour<T> : MonoBehaviour where T : MonoBehaviour Type Parameters Name Description T Properties Instance Declaration public static T Instance { get; } Property Value Type Description T Methods OnApplicationQuit() When Unity quits, it destroys objects in a random order. In principle, a Singleton is only destroyed when application quits. If any script calls Instance after it have been destroyed, it will create a buggy ghost object that will stay on the Editor scene even after stopping playing the Application. Really bad! So, this was made to be sure we're not creating that buggy ghost object. Declaration protected virtual void OnApplicationQuit()"
  },
  "api/CatchIo.Util.TileInfo.html": {
    "href": "api/CatchIo.Util.TileInfo.html",
    "title": "Class TileInfo | Catch.io Developer Reference",
    "keywords": "Class TileInfo Inheritance Object TileInfo Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax public class TileInfo Properties ParantTilemap Declaration public Tilemap ParantTilemap { get; set; } Property Value Type Description Tilemap TilemapObject Declaration public GameObject TilemapObject { get; set; } Property Value Type Description GameObject TilemapSortLayer Declaration public string TilemapSortLayer { get; } Property Value Type Description String TilemapSortOrder Declaration public int TilemapSortOrder { get; } Property Value Type Description Int32 TileRenderer Declaration public TilemapRenderer TileRenderer { get; set; } Property Value Type Description TilemapRenderer"
  },
  "api/CatchIo.Util.TilemapContainer.html": {
    "href": "api/CatchIo.Util.TilemapContainer.html",
    "title": "Class TilemapContainer | Catch.io Developer Reference",
    "keywords": "Class TilemapContainer Inheritance Object TilemapContainer Namespace : CatchIo.Util Assembly : cs.temp.dll.dll Syntax public class TilemapContainer : MonoBehaviour Methods GetTileMaps() Declaration public List<TileInfo> GetTileMaps() Returns Type Description List < TileInfo >"
  },
  "index.html": {
    "href": "index.html",
    "title": "Project Catch.io Developer Reference | Catch.io Developer Reference",
    "keywords": "Project Catch.io Developer Reference Introduction This is the developer reference for Witch One , internally referred to as Project Catch.io . If you are part of development team, feel free to add new tasks or comment on existing ones. Every information that is required for developing with the Project Catch.io team will be documented here. Such information includes: Project folder structure Coding styles and guidelines Project contribution format (semantic version for this project, Pull Request format, etc.) Milestones and progress reporting methods Team roles Documentation format and more... You can think of this as a general guideline and a starting point for joining the team or unifying how our works should be prevented in order for them to be considered 'finished'. To keep things organized, project members should document their work and tell everyone how you want others to handle your work. Please keep in mind that you are not expected to read all the docs, but you are expected to understand the parts that is related to your task. Project Resources All resources and documents related to the development of project Catch.io is split amongst various repositories, sites and services. We will list all of them here and explain what their purposes are. Some links listed here will not be accessible by the public while some are. Please change the list content if we decide to make adjustments to the team management structure. Catch.io Project Repository: The repository for the source code of project Catch.io. This repository is made private, and we only allow access to project developers. However, contents like code documentation or ongoing test builds will be made available to the public with the power of Github CI. Catch.io docs repository : The source code for project developer references are kept in this repository. Currently, this repo contains two different document pages. Project Development Manual : Hosted via Github Pages, this page contains the auto generated scripting reference for this project. The content of this page will change with every update made to the Catch.io source code. It is convenient, but hard to migrate to other pages as this does not use Markdown for API references (only code manuals are in Markdown). Google Drive Shared Folder : Internal documents, weekly meeting records, brainstorming records, project expenses, art/music assets for the project and other information that are meant to be stored for a long time and only meant for team members will be stored here. Non-programmers will mostly interact with Google Drive. Itch.io page : Itch.io is used for sharing quick prototype builds of the game (in WebGL for most cases) both inside and outside the team. Generally, this page is used for quick internal testing, but we may consider releasing the game here at some point. Trello Project Board : Still experimental, but this is where the development progress regarding Catch.io will be tracked. Catch.io GDD : Hosted by Gitbook, this page contains everything about the project such as the game mechanics, expected features, rough timeline, expected release platforms, general marketing strategy, pivot strategies, and more. Abbreviations & Definitions To increase the efficiency of communications between members, it is good to use abbreviations. If there are any abbreviations (and the definition of that word) you are using that is foreign to other new members, please add it here. PR: Pull Request (when merging a branch or a fork to the master repository) Repo: Repository (Git repository) doc: Documentation (Projects documentation like this one will be referred to as docs) WIP: Working In Progress impl: short for implement or implementation LGTM: Looks Good to Me (used when a PR does not have any issues and is good to merge) Scripts: Refers to the .cs code that contains game play logic, but are not directly used as part of a Unity game object Components: This is also a .cs code, but it is meant to be used as a component for Unity game objects How to Write Documents Project docs like this one must be written in Markdown. You can use stackedit.io to write a quick doc, or use the Markdown All in One extension for VS Code. Documentations should be long and comprehensive so anyone can understand. As a general format, think of this README doc as a template to start from. Q: What should be a doc Anything that requires more than one people to work on either now or in the future. Or if you have any special requirements regarding your work or working style, write a doc to express that to other members. Q: Who can write a doc Anyone within the team. You will need other's permission to edit an existing doc (except for fixing typos or obvious problems), but creating a new one is completely up to you. Q: Any word requirements It should be comprehensive, but not boring. There are no strict word count, however it should be long enough to let the reader understand what you want to say and short enough to not make the reader fall asleep."
  },
  "manual/artist-guidelines.html": {
    "href": "manual/artist-guidelines.html",
    "title": "Art Asset Structure | Catch.io Developer Reference",
    "keywords": "Art Asset Structure This section will describe how art assets for Catch.io should be structured. Directory Every art assets used in the game (excluding UI) is stored in Assets/Textures/ . This includes character sprites, environmental objects, throwable objects and map tile sets. Everything relating to the UI such as menu, title, inventory icon, etc will be stored in Assets/Textures/UI/ . Asset import settings When importing the assets to Unity engine, the file settings should be like the following: Texture Type: Sprite (2D and UI) Sprite Mode: Multiple or Single Pixels Per Unit: 32 Filter Mode: Point (no filter) Compression: None When slicing animated sprites, it is recommended to use the Grid by Cell Count method. You can find the detailed image import setting inside the Assets/Editor/Presets/InGameSpriteImport_Default.preset preset file. Submitting Assets For artists who are submitting their work, it is recommended to upload the work to Google Drive Team STEP/Projects/Project Catch.io/Sprites/ folder with the appropriate name of the sprite that is being added. Because Google Drive does not send responsive notifications for uploading images, the artist will have to notify the developer that their work has been uploaded via Slack. Folder Structure Animated character sprites will be placed in the Characters/ folder with the name of the character as the root directory. Inside this folder, there should be a subdirectory that describes the action (ex: Characters/Shade/Walking/ , Characters/Shade/Running/ , Characters/Shade/Crouching/ , etc.). The actual image file will be saved within those folders. Completely optional, but it is recommended to create source folder as well that stores the original work file in any format as a backup solution (ex: Characters/Shade/source/running.aseprite ). Image Format It is recommended that the final asset is saved as .png , but Unity supports a vast number of image formats, so as long as the file can save alpha channel data or layer data (if required), the artist can save it as any format as they want. For any animated sprites, it is recommended to separate the sprite asset into animation sheets like the following sample animation. Character sprites should be separated into each direction where a single image contains all the frames for that direction. The asset file name should be prefixed with the action and suffixed with the direction that the character is facing with a space in between the two. The direction should be named as the cardinal direction (ex: Run NE.png , Walk S.png , etc.). To summarize all of this, character assets should have the format of Characters/{Character Name}/{Action}/{Action Direction}.png . Theses are some examples: Characters/Shade/Walking/Walking NW.png Characters/Shade/Running/Running N.png Characters/Shade/Throwing/Throwing SW.png Item/Torch/Torch1.png Item/Frog/Red Frog/Back.png Asset Color Palette Both characters and props must follow the following color palette to keep a consistent feeling for the visual assets. A single component of an asset (such as metal, gold, cloth, etc.) should be within 2 variations of light to dark palettes/color. Feel free to be creative, but the main idea is that for artists to make an object (e.g a wooden barrel) it should use the same wood colors as the trees in the environment for consistent visuals."
  },
  "manual/coding-style.html": {
    "href": "manual/coding-style.html",
    "title": "Coding Style | Catch.io Developer Reference",
    "keywords": "Coding Style This section will discuss the naming convention of code, files, github branches, etc. If you find any files with inconsistent naming, please fix them accordingly. C# Naming Conventions Because Unity uses C# as its preferred language, the standard C# naming conventions will be used within this project. This scheme will apply to C# script names as well. For further details regarding C# coding conventions, please refer to the following documents: https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/inside-a-program/coding-conventions https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/general-naming-conventions https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/interface https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/names-of-classes-structs-and-interfaces https://blog.submain.com/c-interface-definition-examples/ https://www.c-sharpcorner.com/article/types-of-relationships-in-object-oriented-programming-oops/ Everything else will mostly be kept consistent with Unity/C# conventions, but for this project, we will not be having the m_ prefix for component variables in Unity. Namespaces All C# scripts that are inside the Assets/Scripts folder must have a namespace to it. The namespace should be CatchIo.<folder name> , where the <folder name> is replaced with the folder that the script is in. Unity Asset Names Every asset used within the Unity engine will use the Upper Camel Case (ex: MainCharacter.prefab or GrassLandTileSet.png ). These assets include everything from tile maps, sprites, object prefabs, shaders, etc. Scene names should be in Camel Case as well as items within the scenes too. It's discouraged to use spaces for game object names, but not mandatory as there are some generated objects that does include a space in the name (ex: Main Camera ). Style Rules This project uses EditorConfig to maintain its code style. Some style rules have been disabled due to compatibility with how Unity handles C# scripts. These settings will be automatically read by Visual Studio. For developers using VS Code, we have stored a pre-configured workspace settings and recommended extensions in the .vscode folder for easy configuration. The repository for this project will check for the code style via dotnet-format for every PR. This check must pass in order for new code to be merged to the main branch. Formatting Code Although both VS Code and Visual Studio offers a built-in code cleaner that can be triggered for every save, we found that there are some style rules won't apply with this method. So we recommend using the development version of dotnet-format tool. You can install this tool by using this following command from your terminal: dotnet tool install -g dotnet-format --version 5.0.142902 --add-source https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-tools/nuget/v3/index.json To format the entire script folder, you will have to first open a script in Unity with Visual Studio so that Unity engine can generate the .csproj file. Once that is done, use the following command from the root of this project folder: dotnet-format Catch.io.sln --fix-style warn"
  },
  "manual/development-environment.html": {
    "href": "manual/development-environment.html",
    "title": "Setting up the development environment | Catch.io Developer Reference",
    "keywords": "Setting up the development environment Game Development Environment Unity Engine The development for Catch.io will be in most cases, done in Unity. We recommend installing Unity Hub as it supports various OS and can install multiple versions of the Unity Editor. Installing Unity Hub You can install the latest version of Unity Hub through this link or check the official download page . Note that for Linux users, the link above will download the .AppImage executable of Unity Hub. Alternatively, you can install Unity Hub through the Pop!_Shop in Debian variant systems. Engine Version Currently, we are using Unity version 2019.4.21f1 (b76dac84db26) and will stay in the 2019.4 LTS of Unity unless we must upgrade the engine to the latest major release. You can check the official release archive from this page , or install directly via Unity Hub by clicking this link . For Linux users who run Unity through an .AppImage executable, the deep link installation provided by the Unity release archive may not work. Instead, you will have to pass the deep link URL as a parameter for the application file from your terminal. ./UnityHub.AppImage unityhub://2019.4.21f1/b76dac84db26 Configuring Unity Editor Setting The Default IDE You can change your preferred IDE/Editor in Unity by going to the Edit -> Preferences -> External Tools menu. Regarding how to install the IDE and text editors, please refer to the next section. General Development Environment Version Control Software Git & GitHub Our team uses Git as the main version control software, and GitHub as the repository host: Team STEP GitHub Account Installing The Git Client Most IDEs offer a way to interact with the remote repository. If you have a preferred Git client, you are free to use it. For most developers, our team recommend using GitHub Desktop, as it offers a robust GUI, auto-configuring the global Git settings, and automatically updating repository submodules. You can install GitHub Desktop on Windows 10 and macOS from the official website: GitHub Desktop For Linux users, you can install a fork of GitHub Desktop maintained by Shiftkey ( releases ) For Windows users, we also recommend installing the Windows Git client that comes with the Bash terminal. Bash on Windows allows you to access applications installed with PowerShell as well. Downloading Git Setting Up IDE & Text Editors Visual Studio Community Note: Visual Studio Community is not supported on Linux systems When working with Unity, we generally recommend using Visual Studio, as it provides full support for Unity including breakpoints and unity game object component reference checking. Although Unity will ask you to install Visual Studio before you install the engine in Windows, you might want to have a full installation of Visual Studio if you need extra features. In which case, you can install the IDE from the following link: Visual Studio 2019 | Download for free MonoDevelop MonoDevelop is an open-source cross-platform IDE that supports languages like C#, F#, Visual Basic .NET, and Vala. You can find more information on their homepage . Generally speaking, MonoDevelop is considered to be a replacement for Visual Studio for Linux systems. If you're using Windows 10 or macOS, we recommend installing Visual Studio Community instead of MonoDevelop. This installation guide will assume that the user is working on a Ubuntu-based system (LTS 20.04 or up). First, add the Mono repository to your system. # update your repository. Upgrade any packages if you have to sudo apt update && sudo apt upgrade # install the basic dependencies sudo apt install dirmngr gnupg apt-transport-https ca-certificates # add the mono repository key sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 3FA7E0328081BFF6A14DA29AA6A19B38D3D831EF # add the app repository to your apt source sudo sh -c 'echo \"deb https://download.mono-project.com/repo/ubuntu stable-bionic main\" > /etc/apt/sources.list.d/mono-official-stable.list' # refresh your repository list sudo apt update Second, install the full MonoDevelop package and the IDE # install the full mono package sudo apt install mono-complete # install the monodevelop IDE sudo apt install monodevelop # install the .Net NUit unit test packages sudo apt install monodevelop-nunit Lastly, check your installation # this command should output the compiler version if your installation was complete mono --version Your IDE should look something like this: This guide was based on the article written by Website For Students . Visual Studio Code Visual Studio Code is a lightweight text editor (until you install a boatload of extensions) for developers on all major platforms. There are several Visual Studio Code extensions that work with the Unity Engine. It does not support everything that Visual Studio can do with Unity, but we recommend install VS Code as it is great for development that is outside of Unity (such as web development, or PR review/resolving merge conflicts). You can install Visual Studio Code from the following link: Visual Studio Code - Code Editing. Redefined Visual Studio Code must be configured properly before it can work with Unity. This is the list of recommended extensions that we use at the time of this writing. extensions.json { \"recommendations\": [ \"editorconfig.editorconfig\", \"aaron-bond.better-comments\", \"ms-dotnettools.csharp\", \"jchannon.csharpextensions\", \"streetsidesoftware.code-spell-checker\", \"unity.unity-debug\", \"donjayamanne.githistory\", \"felipecaputo.git-project-manager\", \"github.vscode-pull-request-github\", \"formulahendry.github-actions\", \"eamodio.gitlens\", \"yzhang.markdown-all-in-one\", \"davidanson.vscode-markdownlint\", \"tobiah.unity-tools\", \"ptd.vscode-unitymeta\", \"redhat.vscode-yaml\", \"dotjoshjohnson.xml\" ] } settings.json { \"editor.defaultFormatter\": \"EditorConfig.EditorConfig\", \"markdownlint.config\": { \"html\": true, \"MD033\": false, }, \"[jsonc]\": { \"editor.defaultFormatter\": \"vscode.json-language-features\" }, \"omnisharp.enableEditorConfigSupport\": true, \"editor.formatOnSave\": true, \"cSpell.words\": [ \"Tilemap\", \"Tilemaps\", \"gameplay\", \"royale\", \"tileset\" ] } Editing the contents of the .vscode/ folder in the root directory of the project allows the developer to change the default setting for developers working in VS Code. This means that all developers with a new installation of VS Code has to do is open VS Code from the root of the project folder. Android Studio Android Studio is a cross-platform IDE for developing applications for Android devices, commonly with Java and Kotlin. Our team will rarely develop directly in Android Studio, but installing it allows us to easily install different versions of Android SDK, or access other development tools like the Android Device Emulator. Plus, Android Studio is available for most commonly used OS, so if your disk space can handle it, we recommend installing it from their official installation page. System Terminal and Package Manager Windows 10 - Chocolatey No sane developers will use Windows for its terminal or package management, but here we are. This section will guide you through installing Chocolatey , a package manager for Windows. Windows system comes with PowerShell and the Command Line Prompt as its main terminal. Alternatively, you can install Bash that comes with the Windows Git client (mentioned in the previous section). For this guide, we will be using PowerShell. To access PowerShell with administrative rights, click on the Windows search bar on the bottom left corner of your screen (next to the Windows button in the task bar), and search for PowerShell . Right-click on the app and choose Run as administrator . When you open the terminal, it should look something like this: Note that administrator sessions runs from Windows\\system32 instead of the user home directory. Paste the following command to your terminal. Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) This should install Chocolatey to your system. You can confirm it by using the choco command to your terminal. You can read the detailed installation process from the official installation page . macOS - Homebrew Homebrew is a package manager for macOS. It offers a wide variety of applications that are a must-install for developers working from macOS. Unlike Windows; macOS comes with a zsh terminal, which shares a lot of characteristics of bash. This means that most commands that works with bash will work on your Mac. To install Homebrew, you simply open your terminal from the Utilities folder and paste the following command. /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" You can learn more from the official Homebrew page."
  },
  "manual/github-guide.html": {
    "href": "manual/github-guide.html",
    "title": "Git Guide | Catch.io Developer Reference",
    "keywords": "Git Guide Branches and Forks The basic idea of branches and PRs is, when implementing a new feature for most projects, you would create a branch that is only for that feature. When the development is done you would open a pull request and merge it with the master. We will elaborate on this idea and create a single standard as game development involves many moving parts that rely on each other and it is important for everyone to be on the same page with this. There will be mainly four types of branches. fix branch: a branch name that is used for commits for patches or fixes that address a bug that came from the feature branch. This does not add anything new in terms of features, but only refactors them. Ex) fix/throw-object . feature branch: branches that adds something new to the game which may break the game or not. Because of how game development works, commits in this branch will inadvertently act similar as the fix branch (and it is fine to do that as long as you record it!), but one key difference is that feature branch must add something new. Ex) feature/ai-sensors . development branch: these are the branches that are in active development. They have a very strict rule. First, the name must be the semantic version name. Second, every feature and fix branches must be derived from this branch and merge back to it when finished (no branch should derive from other branches). Lastly, after merging the development branch with the master branch, the development branch should not be touched at all. Ex) development/v-0.0.1b document branch: this is a special branch that is used exclusively for PR that adds documentation to the repo In short, branches with the name development must be derived from the master while the fix and feature branches derive from the latest development branch. Only development branches are allowed to merge with master . However, you can only merge when there are no fix or feature branches, and once you merge you can only create a new development branch, no direct commits to master unless the situation calls for it . Merging a development branch to the master branch will be part of a Milestone . Forking works similar to the fix and feature branch. You can freely fork a development branch and merge back to it. But you should never fork and commit to a fix / feature branch unless you made a new one or you have to! Versioning Scheme By default, projects will use the Semantic Versioning as the base for the versioning scheme. Versions are generally used in three different places. Github tag/dev branch names In-engine version In-game graphical version display In-engine version and the In-game graphical version display will be linked together, allowing the developer to only focus on working with the in-engine version numbering. Those will have to be changed manually. Github version names will be taking the form of development branch names like development/v0.1.3a and will also be the name of Github's Projects feature and Milestones feature. The naming scheme for branch names will be like the following, development/v[major].[minor].[patch][alpha/beta] . The major number is when we add a huge feature that may change the game as a whole. One example would include a multiplayer mode for a singleplayer only game. Adding on to this, minor versions are additional feature that does not affect the game play flow to a huge degree, but does add something new to the existing game. For example, a new character model or new items. Patch numbers are generally when a game changes its backend code that the end-users does not notice right away and updates that does not add something visible to the game. Like bug fixes and gameplay balancing. Using Git Projects and Progress Tracking For tracking the development process, we will be using Git Projects. Git Projects is a simple automated Kanban for understanding what tasks should be done, what is in progress and what is finished. For this project we will be using the automated Kanban, meaning that issues will be automatically added to the Projects Kanban. Project names should be the development version that the project will have. If all the items in the Project are considered to be finished, you can open a new milestone and merge that version with the master branch. After that you would create a new Project with a new version name. For adding items to the Kanban, please create a new Issue with the appropriate label. When adding a new feature to the game, create a new branch with the prefix feature/[feature-name] and open a new issue with the label enhancement . For fixing bugs or other patches, create a new branch with the prefix fix/[patch-name] and open a new issue with the label fix . When you open a new issue, that item will be automatically added to the Project Kanban. GitHub Projects is just a simple method to check the overall progress of the working project and to understand what the developers should be doing. As long as the developer understands to open an issue and creating a new branch before making any changes, there should be no problem. Opening Issues As mentioned above, the project's development progress and assigning tasks will be done via opening issues on the repository. Because of this, it is important to understand the format for opening one in a consistent way. Issue Title: The title of the feature/fix that the assigned developer will make. Description: The detailed description of what this task will be adding. It is best to add a list of things that will be done. Assignees: This shows the developers who will be taking on the task that the issue describes. Labels: The category of the issue. Mostly it will be either enhancement or fix . Projects: The project that this issue will be committing to. This should always be the latest working development build before it is committed to the master branch. Milestone: This shows which development build this issue belongs to. Preventing Merge Conflicts When using Git for version controlling game projects, the team will definitely encounter several critical conflicts. This generally stems from the following reasons: Too much noise - most heavy game engines will create a lot of meta files for various reasons. This is always automatically generated by the engine, which makes it hard to predict how it is going to change. Furthermore, this will clog up the changed file list for each commit and pulls which makes reviewing hard. Too many different file types - most engines will use their custom file types for managing game objects or settings. Sometimes this will result in files being treated as binaries rather than code. Most cases these are just markup languages with a special file extension, but this still makes it hard for developers to review other's code. Large files - not completely related to merge conflicts, but using large media files like .wav or .png makes syncing and merge a time consuming process. So how can we prevent merge conflicts when working with a huge number of team? There is no single solution for this, but we can come up with commit standards to ensure that we can avoid critical errors. The following guide will be based on using Unity with Github Work on a new scene - if you are adding a new feature or item, create a new scene or duplicate one of the existing scenes and only work on that. This ensures that no scene conflicts will ever happen. Only focus on your feature - not limited to game development, but for any collaborative working environment, it is best to only stick on your feature and not try to work on something that is not related to it. Create/override prefabs - always make a prefab for game objects that will be used throughout multiple scenes. Furthermore, before committing to the repo, do not forget to update your prefab."
  },
  "manual/in-game-tilemap.html": {
    "href": "manual/in-game-tilemap.html",
    "title": "In-Game Tilemap System | Catch.io Developer Reference",
    "keywords": "In-Game Tilemap System In this page, we will focus on summarizing two popular tilemap frameworks that we can consider for our project. Available Tilemap Frameworks There are a couple of options you can choose when creating a tile-based 2D game in Unity. All frameworks have their strengths and weaknesses that the developers should consider and commit to that framework to allow the core mechanics to have a consistent performance. Unity 2D Tilemap Unity 2D Tilemap is a tilemap component that Unity offers within their engine. Because it is part of the engine, this framework is highly compatible with most components and other tools within the Unity ecosystem. Plus, it is very flexible when it comes to adding custom features. You can learn more about extending the Unity 2D Tilemap framework from this GitHub repository . Despite the strong support that Unity 2D Tilemap receives from both Unity and the community (hey, that rhymed!), there are limitations that the developer should consider before fully committing to it. One such limitation is with the in-engine editor, as it lacks a lot of tile selection tools and built-in brushes. Another limitation is how complicated the custom brush implementation is alongside the difficulty of extending the existing tilemap framework itself. Pros: Highly compatible with the base engine and other assets Ability to create custom brushes and tile logics Easy composite collider Great documentation Great support from the community Completely free Cons: Difficult to extend the core tilemap component Difficult to create usable custom brushes All tiles are saved as a separate prefab in the project (hard to migrate) Lack of effective custom tile property injection Helpful resources: Unity tilemap manual Tilemap component tutorial Super Tilemap Editor Super Tilemap Editor is a 3rd-party Unity asset that can be bought from the Unity Asset Store for $45. This asset (or plug-in) allows you to create and use 2D tilemap in your game scene. The tile system is based on the position within the specified atlas image, whereas Unity will create a prefab for each individual tiles from a sprite image. Overall, Super Tilemap Editor is a robust package that offers easy in-engine map editing tools. Thanks to the fact that the source code is available to the developer, you can extend and change the plugin from its core. However, Super Tilemap Editor has trouble with importing TMX (Tiled Map Editor XML) files despite it claims to provide full support for it. In addition to that, Super Tilemap Editor lacks in proper documentation or community support compared to that of Unity Tilemap. Pros: Highly expandable Optimized tiling system Robust editing tools Supports tile metadata and custom properties Easy to use Can export tilemaps as prefabs Cons: Not free Lacks in documentation Community size is small compared to Unity Tilemap Issue with importing from TMX files Helpful Resources: Unity forums release thread Super Tilemap Editor Official Page Super Tilemap Editor Documentation"
  },
  "manual/level-designing.html": {
    "href": "manual/level-designing.html",
    "title": "Level Designing | Catch.io Developer Reference",
    "keywords": "Level Designing Game Mechanic and Level Designing Project Catch.io heavily relies on passive mechanics that affects the gameplay-flow. Passive mechanics are game mechanics that the players are expected to always be aware of and actively utilize to win without having a dedicated button to execute it. Examples of such mechanic includes: Visible sound waves Player footprint Environmental objects You can learn more from Game Mechanics and Features section of the game design document. Map Sections This project is expected to have an average of 15 players in a battle-royale-style death-match. A full game map will be divided into small sections that can be either a set of tilemap prefabs or multiple scenes combined together. The level designer will only need to focus on designing these map sections, rather than making the full map at once. Player spawn-points are manually placed by the designer to ensure that the game is balanced for everyone. To keep the map designing process simplified, a single map section will be large enough to handle three player spawn-points , where the distance between any given spawn-point must be more than 64 tiles . This means that the entire map must contain at least 5 sections. The above image is a rough approximation of how the player spawn-point and map edges will be placed. In here, we assume that the space between each spawn-points in a single section is 64 tiles apart. Please note that this is just an example of how the map sections can be combined. The level designer can change the size of a section, or change how they are placed if they need to do so. Map Elements Aside from the visual style, the level designer will have to consider the following elements when making a map. Map Surface: All levels will have a base ground tile and a special surface tile. These surface can leave footprints, generate sound with a higher volume, or slowdown the player. Player Spawn-points: As mentioned above, player spawn-points are manually placed by the level designer. When a player enters a game, they will spawn randomly from a set of locations defined by the designer. Offensive/Evasive Items: Offensive and evasive items are objects that players can keep in their inventory and throw it with the throw button. These items are the primary source of gameplay that allows the player to either attack the other player, or run away from certain situations. Level designers should be mindful of where they should be placed and how many should be accessible in a given section. Consumable Item Spawn-points: Consumable items are essentially health potions for replenishing player's sanity value. Potions use the same inventory slot as the offensive/evasive items, but they are not re-usable once consumed. To keep the gameplay flow going and prevent players dying from lack of potions, consumable items are spawned in a fixed location that only spawn to the location with the least players in the area. Environmental Objects: Environmental objects are map props that is part of the map design. They are not meant to have any player interaction, instead, they are meant to be a static object. However, environmental objects can cast shadows or block bounce-off projectiles, which means that they can be used as a hiding spot or an ambush spot for the player. Light Sources: These are part of the environmental object group, however, instead of being a hiding spot for the player, this will become the area that exposes the player, as players will only be visible to other players when they are being lit. Buildings and Houses: Similar to environmental objects, buildings are a static prop that is part of the map. However, they do not come in a fixed size like a tree would. Players are expected to use buildings and houses as a landmark for map navigation and hiding. Story Telling: When designing a level, the designer should tell a story for each object they place. This aspect of level designing will not be emphasized for the vertical slice of the project, but the release version should be able to tell the game lore and place objects in a way that stays consistent with the story that the designer is trying to tell. Tiled Tilemap Editor The scripting aspect of the project may change depending on the implementation. In order to keep the development flow going, it is important for us to separate the level designing process from the level feature implementation. We do not want the level designers to wait for something coding task to finish, or lose their work when we change or optimize the tilemap system. At the same time, we want a flexible and powerful editing tool that allows the level designer to abstract the features. There are many options when it comes to implementing 2D tilemap systems in Unity. To keep the project development flow clean, we will use a map editing tool called Tiled. You can download it from this link . Tiled is a map editing tool that reads and saves the map information to a file called .tmx which is a form of XML. Tiled comes with various powerful tools and features that makes 2D map designing easy. You can add custom properties to petty much everything starting from the map down to the individual tiles. Thanks to this feature, it is possible to create a concept map that contains features which are not yet implemented in the game. To learn more about what this tool can do, please refer to the Tiled official documentation . Starting a Project The Tiled project will be part of Catch.io's source code under the folder name TiledMapEditor . The location of this folder may change depending on how we decide to import the map data to Unity, but as of this writing, the folder will be in the root directory of the project. To open the project map editor, you will have to load the CatchIoLevels.tiled-project file to Tiled. This file contains the reference to the editor extension location, object type data, auto mapping rules and other information that is required for map designing. Keeping a project file as a single source of reference for all the Tiled files allows us to keep a consistent working environment across different designers. After when you opened a project, all you have to do is double-click the TMX file to open up a map (or create a new one) and make the changes you want. Tiled Project Folder Structure For our project, we will have the following folder structure: Extensions: Contains the Tiled editor extension scripts that can be used by the designer. This folder is a clone of the official extension repository . You can create new extensions and just add it in this folder. The editor will automatically parse through the content. Maps: Contains the TMX tilemap file that the designer will directly work on, plus the auto mapping rules entry point. All game levels designed in Tiled should be saved in this folder. Rules: A subdirectory of Maps . This folder contains the auto mapping rule maps that will be used in this project. All TMX files used here must be referenced in the rules.txt file in the Maps folder if you want the editor to read them. Templates: Contains the map object template file. Objects are useful when you want to reference a Unity prefab or other complicated game-specific logic that is difficult to add using Tiled. When you create an object that is used in other maps, please create a template of it and save it in this folder. Tileset: Contains the tileset information that is used in the map. The tileset source image will always be inside the Assets/Textures/Tileset or Assets/Textures/Props folder. This means that all the tilemap used in Tiled is based on the raw sprites that is read by the game engine. Tileset should match the sprite name that it is based on to reduce confusion. Types: Contains the map object type data. Using types allows the object to have a consistent property which makes it easy for the Unity importer to handle them later on. All types are kept in a single .xml file, so every time you add a new type, you should overwrite the existing one. However, be careful not to change the file name as they are referenced by the .tiled-project file. Useful Features There are a lot of tools and features that you can use in Tiled. Trying to go through all of them will be impractical. Instead, we'll only cover some important features that will be used the most in our project. Overview When you open a TMX file from a Tiled project, you'll be greeted with a tilemap editor screen. This is the place where you will design the game map by placing tiles and objects that will be loaded on to a Unity scene. Project explorer All major files that are inside the Tiled project will be shown here. You can load a tilemap or a tileset by double-clicking the file from here. Having said this, Tiled will try to list all files that are within the project directory, meaning that not all files listed in the explorer can be read by the editor (ex, JavaScript files). Also note that the built-in file explorer is not too responsive, so when you make changes to the files, you may need to manual refresh the view by right-clicking on the section and press refresh. Additionally, you cannot delete files directly from the editor. You will need to open the project folder and delete it from there. Editing Tools The top section contains the various brushes and operations you can do on a tile or an object, like stamps, terrain brushes, Wang brushes, selection, eraser, and more. Some extensions can add additional functions to this section, making it handy to the designer. Property Section You can add or change the property of your map from here. These include built-in properties (settings) such as layer format and the tile size. Custom properties can be viewed from the lower-half section under the 'Custom Properties' header. You can add them by clicking on the blue plus button. Template Editor Templates are map objects that is referenced from a separate file. Although it's not displayed on the above example, when you select a custom object on the map that is saved as a template, or click on a .tx template file from the explorer, you can edit it from here. Changes made to the template will be applied to all the maps that uses it. Script Console Not to be confused with the command feature , which is a predefined bash script, the script console is primarily used for the Tiled scripting extensions, currently implemented for JavaScript and Python. This is more of a debugging tool to see if your project environment has been properly loaded, or to execute scripts directly from the project. Map Layers You can add and change and organize the tile layer from here. There aren't much to talk about layers other than that you can create tile layers, object layers, and image layers. Plus, you can also group multiple layers into a single folder to organize them. Layer name and their content will become important when you want to work with the auto mapping feature. Other than that, layers work exactly the way how you would expect it to work on most editing tools. Tileset/Terrain Selection You can choose which tile you want to place by selecting it from here. If you select a tile with the stamp brush, that will place the tile selection directly to the map. You can choose your terrain type or the Wang tilesets from their respective tabs which is located at the bottom."
  },
  "manual/project-structure.html": {
    "href": "manual/project-structure.html",
    "title": "Project Structure | Catch.io Developer Reference",
    "keywords": "Project Structure This chapter will discuss the file structure of this project and how the project should be organized. Because of how game development works, this chapter will change depending on what type of assets we add to the game. In such situation, please update this doc to the corresponding changes so no one is confused to where things are stored. Core Folder Types This project will have the following core folder types: Audio - contains every asset that is in an audio format like background music, in-game sound effects, UI sound effects, background sound, etc. Editor - C# scripts that are specifically made for the Unity Editor to support development. Game-affecting logic does not belong in this folder. Gizmos - Similar to the Editor folder, this folder will contain all visual assets that are used for the editor, like inspector icons or other visual indicators. Materials - Contains all material assets (in the format of .mat ) that are used in the game. Plugins - Third-party libraries from the Unity Asset Store or helper scripts that does not change frequently and is compatible with other Unity projects should be stored in this folder. Resources - contains all game object resources like object prefabs, rule tiles, scriptable objects, etc. Scenes - games scene will be in this folder Scripts - every script that is directly made for the project belongs in this folder. Shaders - shader files will be in this folder. Textures - every 2D image files will be in this folder. This includes tile map, character sprite, UI elements, etc. Structuring Code General Structure Note: This section is outdated and will need revision in the near future It is recommended that all scripts are Duck-typed (use logical naming and inheritance/interface for all scripts that will be expanded in the future) and use inheritance to neatly wrap the function of each component. This means that scripts with similar functionality should be wrapped with a parent class that inherits from MonoBehaviour (or another class that inherits from it like MonoBehaviourPun ). The same logic will apply to folder structuring as well. Interacting with the UI In Unity, scene elements and the code are kept separate, as they only communicate through an event callback. So scenes that requires user interaction through UI elements must have a scene manager or a UI handler object of sort. To increase code scalability, the HUD or menu UI objects should be kept separated from the backend logic that handles the data for UI to display. Instead, allow the UI controller script to interact with the scene objects and relay the user input into a handler script. This can resemble a simplified version of the MVC pattern. In this model, the UI behavior script and the scene manager script should be in the same game object so that the manager script can access the UI behavior script via .GetComponent<T>(); . Folder Structure Because the project source code is expected to grow and change with every new feature added to the game, it won't be practical trying to limit the number of code sub-folders in the game. Instead, this section will define the categories of the source code that we expect to be bundled in a folder. A single category can be split into multiple folders, or sub-folders when needed. It is good to keep the actual name of the folder should be descriptive enough for people to understand, but this document will not try to come up with any as we want the developers to change the name or add more when they have to. Folders should be kept flexible and descriptive. Furthermore, developers should keep all components and data types on a separate script and try to group all similar codes into a folder. If a component behavior script becomes hard to categorize into a single folder even though they share similar characteristics, let it inherent from a parent class that implements those behaviors and place the child script into their own folders that best describes them. Because all game-related .cs files are expected to be stored inside the Assets/Scripts/ folder, the code category listed below will describe the general folder structure inside the Scripts/ folder and nowhere else. This means the following definitions will not be applicable to codes inside Editor/ or Plugins/ folder. Core classes - The core types and components that are used to build other game components. Everything in this category are not expected to be used directly in the game. Instead, they should be the template for creating new components. This will also include custom types that does not inherit from anything. UI controller classes - Components specifically for controlling the UI or in-game HUD. Most, if not all of them should have using UnityEngine.UI; in one way or another. Interfaces/Enums/Struct - It is best to keep all the interface, enum, data structure code into a separate folder, as it allows the team to understand what interfaces are written by us and which ones are from a 3rd party library. Utility classes - These classes are static functions that is only used to prevent writing the same method inside a component over and over again. Scripts in this category are expected to be used throughout different components without any dependency issue. Map prop classes - All components that are used for environmental objects but is not directly controlled by the player should be kept in the same folder. For example, a script for opening a door. Sound manager classes - Sound (music and SFX) is a crucial game play aspect for Catch.io, so we can expect separate scripts that handles this logic. Controllable object classes - All scripts and components that are meant to be directly controlled by the client (aka, the player components) should be kept in the same folder. These should not be confused with the UI controller classes, as those are independent of the player object. Game manager classes - Components that are meant to handle the backend processing of a scene will be organized into its own folder."
  }
}